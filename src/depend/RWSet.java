package depend;

import java.util.Set;

import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.types.FieldReference;
import com.ibm.wala.types.TypeReference;

/****
 * 
 * auxiliary class denoting a pair of sets (of field references):
 * one to characterize the field reads of one method and
 * another to characterize the field writes of one method
 * 
 * @author damorim
 *
 ***/
public class RWSet {

  // This class encapsulates the information that should be in the nodes of the dependency graph. See docs/project1.txt
  public final static class AccessInfo {
    public final IClass accessClass;
    public final IMethod accessMethod;
    public final int accessLineNumber;
    public final TypeReference fieldDefinitionClass;
    public final FieldReference fieldDefinition;
    
    private AccessInfo(IClass accessClass, IMethod accessMethod, 
        int accessLineNumber, TypeReference fieldDefinitionClass, FieldReference fieldDefinition) {
          this.accessClass = accessClass;
          this.accessMethod = accessMethod;
          this.accessLineNumber = accessLineNumber;
          this.fieldDefinitionClass = fieldDefinitionClass;
          this.fieldDefinition = fieldDefinition;
    }

    // auto-generated by Eclipse
    @Override
    public int hashCode() {
      final int prime = 31;
      int result = 1;
      result = prime * result + ((accessClass == null) ? 0 : accessClass.hashCode());
      result = prime * result + accessLineNumber;
      result = prime * result + ((accessMethod == null) ? 0 : accessMethod.hashCode());
      result = prime * result + ((fieldDefinition == null) ? 0 : fieldDefinition.hashCode());
      result = prime * result + ((fieldDefinitionClass == null) ? 0 : fieldDefinitionClass .hashCode());
      return result;
    }

   // auto-generated by Eclipse
    @Override
    public boolean equals(Object obj) {
      if (this == obj)
        return true;
      if (obj == null)
        return false;
      if (getClass() != obj.getClass())
        return false;
      AccessInfo other = (AccessInfo) obj;
      if (accessClass == null) {
        if (other.accessClass != null)
          return false;
      } else if (!accessClass.equals(other.accessClass))
        return false;
      if (accessLineNumber != other.accessLineNumber)
        return false;
      if (accessMethod == null) {
        if (other.accessMethod != null)
          return false;
      } else if (!accessMethod.equals(other.accessMethod))
        return false;
      if (fieldDefinition == null) {
        if (other.fieldDefinition != null)
          return false;
      } else if (!fieldDefinition.equals(other.fieldDefinition))
        return false;
      if (fieldDefinitionClass == null) {
        if (other.fieldDefinitionClass != null)
          return false;
      } else if (!fieldDefinitionClass.equals(other.fieldDefinitionClass))
        return false;
      return true;
    }
  }
  
  public static AccessInfo makeAccessInfo(IClass accessClass, IMethod accessMethod, 
      int accessLineNumber, TypeReference fieldDefinitionClass, FieldReference fieldDefinition) {
    return new RWSet.AccessInfo(accessClass, accessMethod, accessLineNumber, fieldDefinitionClass, fieldDefinition);
  }
  
  protected Set<AccessInfo> readSet, writeSet;
  
  public RWSet(Set<AccessInfo> readSet, Set<AccessInfo> writeSet) {
    super();
    this.readSet = readSet;
    this.writeSet = writeSet;
  }

  /**
   * Returns a new <code>RWSet</code> by merging this readSet/writeSet with <code>other</code>'s readSet/writeSet.
   * Changes in the source <code>RWSet</code>s won't affect the returned set or vice-versa.
   * @param other the other <code>RWSet</code> to merge with this
   * @return a new RWSet representing the union of this' readSet/writeSet and <code>other</code>'s readSet/writeSet  
   */
  public RWSet merge(RWSet other){
    // TODO: Deal with null readSet/writeSets? Or we are assume they can't be null?
//    Map<Set<FieldReference>,String> mergedReadSet = new HashSet<FieldReference>(this.readSet);
//    mergedReadSet.addAll(other.readSet);
//    Set<FieldReference> mergedWriteSet = new HashSet<FieldReference>(this.writeSet);
//    mergedWriteSet.addAll(other.writeSet);
//    return new RWSet(mergedReadSet, mergedWriteSet);
    return null;
  }
  
  public String toString() {
    StringBuffer sb = new StringBuffer();
    sb.append("READS FROM:");
    sb.append("\n");
    for (AccessInfo readAccessInfo: readSet) {
      sb.append(readAccessInfo.toString() + "\n");
    }
    System.out.println("WRITES TO:");
    for (AccessInfo writeAccessInfo: writeSet) {
      sb.append(writeAccessInfo.toString() + "\n");
    }
    return sb.toString();
  }
}